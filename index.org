#+REVEAL_THEME: night
#+OPTIONS: toc:1, num:nil, f:t
#+REVEAL_ROOT: file:///Users/timmciver/Workspace/reveal.js



* The Problem Statement

** Can we attain the same level of generalized dispatch on values of a type using an Object-Oriented language that our friends using functional languages enjoy?
#+ATTR_REVEAL: :frag appear
Answer: Yes!
#+ATTR_REVEAL: :frag appear
Well, almost.


* What is Pattern Matching?

** 
Given the following Scala code:
#+BEGIN_SRC scala
case class Point(x: Double, y: Double)

sealed trait Shape
final case class Circle(radius: double) extends Shape
final case class Square(side: double) extends Shape
final case class Triangle(p1: Point, p2: Point, p3: Point) extends Shape
#+END_SRC

You can use pattern matching to implement the ~area~ function:

#+BEGIN_SRC scala
object Shape {

  def area(shape: Shape) shape match {
    case Circle(r) => Pi * r * r
    case Square(side) => side * side
    case Triangle(p1, p2, p3) => ??? // some calculation involving p1, p2 and p3 :)
  }
}
#+END_SRC

** 
Underscore matches anything:
#+BEGIN_SRC scala
object MyShapeApp {

  def hasCorners(shape: Shape) = shape match {
    case Circle(_) => false
    case _ => true
  }
}
#+END_SRC

** 
You can match on type:
#+BEGIN_SRC scala
object MyShapeApp {

  def circles(shapes: List[Shape]): List[Circle] = shapes match {
    case List(c: Circle, rest) => c :: circles(rest)
    case List(_, rest) => circles(rest)
    case Nil => Nil
  }
}
#+END_SRC

** 
It's recursive:
#+BEGIN_SRC scala
object MyShapeApp {

  def countCircles(shapes: List[Shape]): Int = shapes match {
    case List(Circle(_), rest) => 1 + countCircles(rest)
    case List(_, rest) => countCircles(rest)
    case Nil => 0
  }
}
#+END_SRC

** 
And exhaustive.  The following gives a warning:
#+BEGIN_SRC scala
object MyShapeApp {

  def area(shape: Shape) shape match {
    case Circle(r) => Pi * r * r
    case Square(side) => side * side
    // what about Triangle?
  }
}
#+END_SRC


* An Example

** Dispatching on Values in Scala
#+BEGIN_SRC scala
sealed trait Pet

object Pet {

  case object class Dog extends Pet
  case object class Cat extends Pet
  case object class Goldfish extends Pet

  def hasFur(pet: Pet) = pet match {
    case Dog => true
    case Cat => true
    case Goldfish => false
  }
}
#+END_SRC

** Dispatching on Values in PHP
#+BEGIN_SRC php
interface Pet {
  function hasFur();
}

class Dog implements Pet {
  public function hasFur() { return true; }
}

class Cat implements Pet {
  public function hasFur() { return true; }
}

class Goldfish implements Pet {
  public function hasFur() { return false; }
}

// caller doesn't necessarily know the runtime
// type of $myPet - and shouldn't care.
$myPet->hasFur();
#+END_SRC

** Use in a Pet Store Application (Scala)
A part of the application needs to know what pets a given pet might attack.

#+BEGIN_SRC scala
object PetStore {

  def mayAttack(pet: Pet): Seq[Pet] = pet match {
    case Dog => List(Cat)
    case Cat => List(Dog, Goldfish)
    case Goldfish => List()
  }
}
#+END_SRC

** Use in a Pet Store Application (PHP)
#+BEGIN_SRC php
interface Pet {
  function hasFur();
  function mayAttack();
}

class Dog implements Pet {
  public function hasFur() { return true; }
  public function mayAttack() { return [new Cat()]; }
}

class Cat implements Pet {
  public function hasFur() { return true; }
  public function mayAttack() { return [new Dog(), new Goldfish()]; }
}

class Goldfish implements Pet {
  public function hasFur() { return false; }
  public function mayAttack() { return []; }
}
#+END_SRC

** But if you could, should you?
Doing this in an OO language has several drawbacks:
#+ATTR_REVEAL: :frag (appear)
- Requires you to modify the existing classes
- Adds bloat to those classes
- Places logic far from the module in which it is used

** Sometimes you can't, even if you want to
If you don't control the classes you wish to dispatch on, you have to resort to using ~instanceof~:
#+BEGIN_SRC php
class PetStore {

  function mayAttack($pet) {
    $mayAttack = [];
    if ($pet instanceof Dog) {
      $mayAttack = [new Cat()];
    } else if ($pet instanceof Cat) {
      $mayAttack = [new Dog(), new Goldfish()];
    }

    return $mayAttack;
  }
}
#+END_SRC

** A Solution
What if ~Pet~ looked like the following?
#+BEGIN_SRC php
interface Pet {
  function callYourFunction($functionMap);
}

class Dog implements Pet {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Dog'], [$this]);
  }
}

class Cat implements Pet {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Cat'], [$this]);
  }
}

class Goldfish implements Pet {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Goldfish'], [$this]);
  }
}
#+END_SRC

** A Solution (Continued)
Define and Use a Function Map
#+BEGIN_SRC php
$hasFurFunctionMap = [
  'Dog' => function($dog) {
             return true;
           }
  'Cat' => function($dog) {
             return true;
           }
  'Goldfish' => function($dog) {
                  return false;
                }
];

$hasFur = $pet->callYourFunction($hasFurFunctionMap);
#+END_SRC

** Another Solution
Instead of a map, let's use an interface
#+BEGIN_SRC php
interface PetFunctions {
  function functionForDog($dog);
  function functionForCat($cat);
  function functionForGoldfish($goldfish);
}
#+END_SRC

#+ATTR_REVEAL: :frag appear
And implement that interface:
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC php
class HasFurFunctions implements PetFunctions {
  function functionForDog($dog) { return true; }
  function functionForCat($cat) { return true; }
  function functionForGoldfish($goldfish) { return false; }
}
#+END_SRC

** Another Solution (Continued)
And change ~Pet~ to the following:
#+BEGIN_SRC php
interface Pet {
  function callYourFunction($petFunctions);
}

class Dog implements Pet {
  function callYourFunction($petFunctions) {
    return $petFunctions->functionForDog($this);
  }
}

class Cat implements Pet {
  function callYourFunction($petFunctions) {
    return $petFunctions->functionForCat($this);
  }
}

class Goldfish implements Pet {
  function callYourFunction($petFunctions) {
    return $petFunctions->functionForGoldfish($this);
  }
}
#+END_SRC

** Another Solution (Continued)
Finally, use the ~HasFur~ ~PetFunctions~:
#+BEGIN_SRC php
$hasFur = $pet->callYourFunction(new HasFurFunctions());
#+END_SRC
