#+REVEAL_THEME: night
#+OPTIONS: toc:1, num:nil, f:t
#+REVEAL_ROOT: file:///Users/timmciver/Workspace/reveal.js



* The Problem Statement

** Can we attain the same level of generalized dispatch on values of a type using an Object-Oriented language that our friends using functional languages enjoy?
#+ATTR_REVEAL: :frag appear
Answer: Yes!
#+ATTR_REVEAL: :frag appear
Well, almost.


* An Example

** Dispatching on Values in Scala
#+BEGIN_SRC scala
sealed trait Pet

object Pet {

  case object class Dog extends Pet
  case object class Cat extends Pet
  case object class Goldfish extends Pet

  def hasFur(pet: Pet) = pet match {
    case Dog => true
    case Cat => true
    case Goldfish => false
  }
}
#+END_SRC

** Dispatching on Values in PHP
#+BEGIN_SRC php
interface Pet {
  function hasFur();
}

class Dog implements Pet {
  public function hasFur() { return true; }
}

class Cat implements Pet {
  public function hasFur() { return true; }
}

class Goldfish implements Pet {
  public function hasFur() { return false; }
}

// caller doesn't necessarily know the runtime
// type of $myPet - and shouldn't care.
$myPet->hasFur();
#+END_SRC

** Use in a Pet Store Application (Scala)
A part of the application needs to know what pets a given pet might attack.

#+BEGIN_SRC scala
object PetStore {

  def mayAttack(pet: Pet): Seq[Pet] = pet match {
    case Dog => List(Cat)
    case Cat => List(Dog, Goldfish)
    case Goldfish => List()
  }
}
#+END_SRC

** Use in a Pet Store Application (PHP)
#+BEGIN_SRC php
interface Pet {
  function hasFur();
  function mayAttack();
}

class Dog implements Pet {
  public function hasFur() { return true; }
  public function mayAttack() { return [new Cat()]; }
}

class Cat implements Pet {
  public function hasFur() { return true; }
  public function mayAttack() { return [new Dog(), new Goldfish()]; }
}

class Goldfish implements Pet {
  public function hasFur() { return false; }
  public function mayAttack() { return []; }
}
#+END_SRC

** But if you could, should you?
Doing this in an OO language has several drawbacks:
#+ATTR_REVEAL: :frag (appear)
- Requires you to modify the existing classes
- Adds bloat to those classes
- Places logic far from the module in which it is used

** Sometimes you can't, even if you want to
If you don't control the classes you wish to dispatch on, you have to resort to using ~instanceof~:
#+BEGIN_SRC php
class PetStore {

  function mayAttack($pet) {
    $mayAttack = [];
    if ($pet instanceof Dog) {
      $mayAttack = [new Cat()];
    } else if ($pet instanceof Cat) {
      $mayAttack = [new Dog(), new Goldfish()];
    }

    return $mayAttack;
  }
}
#+END_SRC

** A Solution
What if ~Pet~ looked like the following?
#+BEGIN_SRC php
interface Pet {
  function callYourFunction($functionMap);
}

class Dog implements Pet {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Dog'], [$this]);
  }
}

class Cat implements Pet {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Cat'], [$this]);
  }
}

class Goldfish implements Pet {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Goldfish'], [$this]);
  }
}
#+END_SRC

** A Solution (Continued)
Define and Use a Function Map
#+BEGIN_SRC php
$hasFurFunctionMap = [
  'Dog' => function($dog) {
             return true;
           }
  'Cat' => function($dog) {
             return true;
           }
  'Goldfish' => function($dog) {
                  return false;
                }
];

$hasFur = $pet->callYourFunction($hasFurFunctionMap);
#+END_SRC

** Another Solution
Instead of a map, let's use an interface
#+BEGIN_SRC php
interface PetFunctions {
  function functionForDog($dog);
  function functionForCat($cat);
  function functionForGoldfish($goldfish);
}
#+END_SRC

#+ATTR_REVEAL: :frag appear
And implement that interface:
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC php
class HasFurFunctions implements PetFunctions {
  function functionForDog($dog) { return true; }
  function functionForCat($cat) { return true; }
  function functionForGoldfish($goldfish) { return false; }
}
#+END_SRC

** Another Solution (Continued)
And change ~Pet~ to the following:
#+BEGIN_SRC php
interface Pet {
  function callYourFunction($petFunctions);
}

class Dog implements Pet {
  function callYourFunction($petFunctions) {
    return $petFunctions->functionForDog($this);
  }
}

class Cat implements Pet {
  function callYourFunction($petFunctions) {
    return $petFunctions->functionForCat($this);
  }
}

class Goldfish implements Pet {
  function callYourFunction($petFunctions) {
    return $petFunctions->functionForGoldfish($this);
  }
}
#+END_SRC

** Another Solution (Continued)
Finally, use the ~HasFur~ ~PetFunctions~:
#+BEGIN_SRC php
$hasFur = $pet->callYourFunction(new HasFurFunctions());
#+END_SRC


* Review of Some Fundamentals

** What is a type?

A type is simply a set of values.

For example:
- booleans can have a value of "true" or "false"
- integers can be any integer, usually within some range.

** Dynamic Dispatch

** Algebraic Data Types


* Simulating ADTs in OO

** Can We Have Algebraic Data Types in an OO Language? Yes!



* The Visitor Pattern to the Rescue!
