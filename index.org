#+REVEAL_THEME: league
#+OPTIONS: toc:1, num:nil, f:t
#+REVEAL_ROOT: file:///Users/timmciver/Workspace/reveal.js



* The Problem Statement

** Can we attain the same level of generalized dispatch on values of a type using an Object-Oriented language that our friends using functional languages enjoy?
#+ATTR_REVEAL: :frag appear
Answer: Yes!
#+ATTR_REVEAL: :frag appear
Well, almost.


* What is Pattern Matching?

** 
Given the following Scala code:
#+BEGIN_SRC scala
case class Point(x: Double, y: Double)

sealed trait Shape
final case class Circle(radius: double) extends Shape
final case class Square(side: double) extends Shape
final case class Triangle(p1: Point, p2: Point, p3: Point) extends Shape
#+END_SRC

You can use pattern matching to implement the ~area~ function:

#+BEGIN_SRC scala
object Shape {

  def area(shape: Shape) shape match {
    case Circle(r) => Pi * r * r
    case Square(side) => side * side
    case Triangle(p1, p2, p3) => ??? // some calculation involving p1, p2 and p3 :)
  }
}
#+END_SRC

** 
Underscore matches anything:
#+BEGIN_SRC scala
object MyShapeApp {

  def hasCorners(shape: Shape) = shape match {
    case Circle(_) => false
    case _ => true
  }
}
#+END_SRC

** 
You can match on type:
#+BEGIN_SRC scala
object MyShapeApp {

  def circles(shapes: List[Shape]): List[Circle] = shapes match {
    case List(c: Circle, rest) => c :: circles(rest)
    case List(_, rest) => circles(rest)
    case Nil => Nil
  }
}
#+END_SRC

** 
It's recursive:
#+BEGIN_SRC scala
object MyShapeApp {

  def countCircles(shapes: List[Shape]): Int = shapes match {
    case List(Circle(_), rest) => 1 + countCircles(rest)
    case List(_, rest) => countCircles(rest)
    case Nil => 0
  }
}
#+END_SRC

** 
And exhaustive.  The following gives a warning:
#+BEGIN_SRC scala
object MyShapeApp {

  def area(shape: Shape) shape match {
    case Circle(r) => Pi * r * r
    case Square(side) => side * side
    // what about Triangle?
  }
}
#+END_SRC


* Dispatching in OOP

** Dispatching on Values in PHP
#+BEGIN_SRC php
  interface Shape {
    function area();
  }

  class Circle implements Shape {
    private $radius;
    public function area() { return 3.1416 * $this->radius * $this->radius; }
  }

  class Square implements Shape {
    private $side;
    public function area() { return $this->side * $this->side; }
  }

  class Triangle implements Shape {
    private $p1, $p2, $p3;
    public function area() { return /* something involving $p1, $p2 and $p3 :) */; }
  }

  // caller doesn't necessarily know the runtime
  // type of $myShape - and shouldn't care.
  $myShape->area();
#+END_SRC

** 
Similarly for the ~hasCorners~ method:
#+BEGIN_SRC php
  interface Shape {
    function area();
    function hasCorners();
  }

  class Circle implements Shape {
    private $radius;
    public function area() { return 3.1416 * $this->radius * $this->radius; }
    public function hasCorners() { return false; }
  }

  class Square implements Shape {
    private $side;
    public function area() { return $this->side * $this->side; }
    public function hasCorners() { return true; }
  }

  class Triangle implements Shape {
    private $p1, $p2, $p3;
    public function area() { return /* something involving $p1, $p2 and $p3 :) */; }
    public function hasCorners() { return true; }
  }
#+END_SRC

** But if you could, should you?
Doing this in an OO language has several drawbacks:
#+ATTR_REVEAL: :frag (appear)
- Requires you to modify the existing classes
- Adds bloat to those classes
- Places logic far from the module in which it is used

** Use in a Client Application
But what if you can't? How can you implement the ~hasCorners~ function if you can't modify the ~shapes~ library?
#+ATTR_REVEAL: :frag appear
No choice but to resort to using ~instanceof~
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC php
  class SomeShapeApp {

    function hasCorners($shape) {
      return $shape instanceof Square
	  || $shape instanceof Triangle;
    }
  }
#+END_SRC

#+ATTR_REVEAL: :frag appear
OK, that's not so bad but if new versions of the ~shape~ library add shapes with corners, this code will be broken.


* Solutions

** First Solution
What if ~Shape~ looked like the following?
#+BEGIN_SRC php
interface Shape {
  function callYourFunction($functionMap);
}

class Circle implements Shape {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Circle'], [$this]);
  }
}

class Square implements Shape {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Square'], [$this]);
  }
}

class Triangle implements Shape {
  function callYourFunction($functionMap) {
    return call_user_func($functionMap['Triangle'], [$this]);
  }
}
#+END_SRC

** First Solution
Then we define and use a function map:
#+BEGIN_SRC php
  $hasCornersFunctionMap = [
    'Circle' => function($circle) {
      return false;
    }
    'Square' => function($square) {
      return true;
    }
    'Triangle' => function($triangle) {
      return true;
    }
  ];

  $hasCorners = $shape->callYourFunction($hasCornersFunctionMap);
#+END_SRC

** Second Solution
Instead of a map, let's use an interface
#+BEGIN_SRC php
interface ShapeFunctions {
  function functionForCircle($circle);
  function functionForSquare($square);
  function functionForTriangle($triangle);
}
#+END_SRC

#+ATTR_REVEAL: :frag appear
And implement that interface:
#+ATTR_REVEAL: :frag appear
#+BEGIN_SRC php
class HasCornersFunctions implements ShapeFunctions {
  function functionForCircle($circle) { return false; }
  function functionForSquare($square) { return true; }
  function functionForTriangle($triangle) { return true; }
}
#+END_SRC

** Second Solution (Continued)
And change ~Shape~ to the following:
#+BEGIN_SRC php
interface Shape {
  function callYourFunction($shapeFunctions);
}

class Circle implements Shape {
  function callYourFunction($shapeFunctions) {
    return $shapeFunctions->functionForCircle($this);
  }
}

class Square implements Shape {
  function callYourFunction($shapeFunctions) {
    return $shapeFunctions->functionForSquare($this);
  }
}

class Triangle implements Shape {
  function callYourFunction($shapeFunctions) {
    return $shapeFunctions->functionForTriangle($this);
  }
}
#+END_SRC

** Second Solution (Continued)
Finally, use ~HasCornersFunctions~:
#+BEGIN_SRC php
$hasCorners = $shape->callYourFunction(new HasCornersFunctions());
#+END_SRC
